{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome Neerby SDK iOS\n\n\nFor more details about the project visit \nNeer.by\n\n\nThe complete API is available \nHere", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-neerby-sdk-ios", 
            "text": "For more details about the project visit  Neer.by  The complete API is available  Here", 
            "title": "Welcome Neerby SDK iOS"
        }, 
        {
            "location": "/include_in_project/", 
            "text": "Hardware \n software requirements\n\n\nThe Neerby SDK uses Bluetooth 4.0 BLE (Bluetooth Low Energy) and thus is only available on the following devices:\n\n\n\n\niPhone 4S and up\n\n\niPod Touch 5th generation and up\n\n\niPad 3rd generation and up\n\n\niPad mini (all versions)\n\n\n\n\nMinimum iOS target : iOS 7\n\n\nXcode 6 or higher is required for development\n\n\nThe Neerby SDK supports App Transport Security, no exception is required\n\n\nInstallation\n\n\nYou must perform the following tasks to integrate the Neerby SDK with your application:\n\n\n\n\nGet your application ID\n\n\nImport required frameworks \n BeaconForStoreStorage.bundle manually or using \nCocoa Pods\n\n\nConfigure application modes\n\n\nAllow location usage\n\n\nCode-level integration\n\n\n\n\nGet your application ID\n\n\nIn order to use the SDK you must know the application ID that is tied to your Neerby account. \n\n\nUsing the web interface\n\n\n\n\nGo to \nhttps://manager.neer.by\n\n\nLog-in with your Neerby account\n\n\nGo to the \"Applications\" section\n\n\nSelect your application ID\n\n\n\n\nUsing Neerby Manager\n\n\n\n\nInstall the \nNeerby Manager\n app from the App Store\n\n\nLog-in with your Neerby account\n\n\nGo to the \"Applications\" section\n\n\nTap on your application\n\n\nUse the \"Share\" button on the \"Application ID\" section to send the application ID to yourself as an email.\n\n\n\n\nAdding the files manually\n\n\nUse the following instructions to manually add the SDK to your project\n\n\nImport frameworks\n\n\n\n\nDownload the latest version from \nGit Hub\n\n\nExtract the zip archive\n\n\nDrag \n drop the BeaconForStoreSDK.framework onto your project\n\n\nCheck the \"Copy items if needed\" box\n\n\nAdd the Framework to your application target\n\n\nClick \"Finish\"\n\n\n\n\nAdd linker flags\n\n\n\n\nOpen Project Settings -\n Build Settings\n\n\nScroll to the \"Linking\" section\n\n\n\n\nIn \"Other Linker Flags\" add \"-ObjC\" (this setting is case-sensitive) and \"-lsqlite3\"\n\n\n\n\n\n\n\n\nImport BeaconForStoreStorage.bundle\n\n\n\n\nDrag \n drop the BeaconForStoreStorage.bundle onto your project\n\n\nCheck the \"Copy items if needed\" box\n\n\nAdd the bundle to your application target\n\n\nClick \"Finish\"\n\n\n\n\nCheck if the bundle appears in the \"Copy File\" step of your application target\n\n\n\n\nUse Cocoa Pods\n\n\n\n\n\n\nAdd   pod 'BeaconForStoreSDK' to the \"target\" section of your podfile\n\n\n\n\nRun the pod install command\n\n\n\n\nConfigure application modes\n\n\nTo be able to track the beacons even when in background mode, you must enable background modes in your application.\n\n\n\n\nSelect your project in the Project navigator\n\n\nSelect your application target\n\n\nSelect the \"Capabilities\" tab\n\n\nTurn on \"Background Modes\"\n\n\n\n\nCheck the \"Background fetch\" mode\n\n\n\n\n\n\n\n\nThe application will be started by iOS when entering a geofence region or detecting an iBeacon, thus the didFinishLaunchingWithOptions: method from your app delegate will be called.\n\n\nSo if your app calls a tagging / analytics tool (Flurry, Google Analytics...) from this method, your metrics will be eroneous. You should use the  'applicationWillEnterForeground' delegate method to track application launches instead.\n\n\nAdd keys to Info.plist\n\n\nStarting with iOS8, you \nmust\n add a key to your Info.plist to be able to get the user location.\n\n\n\n\nOpen your Info.plist file\n\n\nAdd a NSLocationAlwaysUsageDescription key\n\n\nSet its value to a string describing the reason for accessing the user\u2019s location information\n\n\n\n\nThe Backgound Location is needed by the SDK to allow a caching mechanism of the contextual contents associated to the iBeacon around the user. By using this cache, the SDK deals with the scalability of the contextual contents produced in the Neerby plateform (not all the contents available are downloaded into all active user smartphone) , and allow the user to receive the content when he comes in range of the known iBeacon, even if he has no network at this stage (ie. inside a store)\n\n\nPlease see \nthis document\n for more information\n\n\nStarting with iOS 10 (and app compiled with the Xcode 8 toolchain) you must explain why you app uses Bluetooth otherwise the binary is rejected on iTunes Connect\n\n\n\n\nOpen your Info.plist file\n\n\nAdd a NSBluetoothPeripheralUsageDescription key\n\n\nSet its value to a string describing the reason for accessing Bluetooth", 
            "title": "Include the SDK in your project"
        }, 
        {
            "location": "/include_in_project/#hardware-software-requirements", 
            "text": "The Neerby SDK uses Bluetooth 4.0 BLE (Bluetooth Low Energy) and thus is only available on the following devices:   iPhone 4S and up  iPod Touch 5th generation and up  iPad 3rd generation and up  iPad mini (all versions)   Minimum iOS target : iOS 7  Xcode 6 or higher is required for development  The Neerby SDK supports App Transport Security, no exception is required", 
            "title": "Hardware &amp; software requirements"
        }, 
        {
            "location": "/include_in_project/#installation", 
            "text": "You must perform the following tasks to integrate the Neerby SDK with your application:   Get your application ID  Import required frameworks   BeaconForStoreStorage.bundle manually or using  Cocoa Pods  Configure application modes  Allow location usage  Code-level integration", 
            "title": "Installation"
        }, 
        {
            "location": "/include_in_project/#get-your-application-id", 
            "text": "In order to use the SDK you must know the application ID that is tied to your Neerby account.", 
            "title": "Get your application ID"
        }, 
        {
            "location": "/include_in_project/#using-the-web-interface", 
            "text": "Go to  https://manager.neer.by  Log-in with your Neerby account  Go to the \"Applications\" section  Select your application ID", 
            "title": "Using the web interface"
        }, 
        {
            "location": "/include_in_project/#using-neerby-manager", 
            "text": "Install the  Neerby Manager  app from the App Store  Log-in with your Neerby account  Go to the \"Applications\" section  Tap on your application  Use the \"Share\" button on the \"Application ID\" section to send the application ID to yourself as an email.", 
            "title": "Using Neerby Manager"
        }, 
        {
            "location": "/include_in_project/#adding-the-files-manually", 
            "text": "Use the following instructions to manually add the SDK to your project", 
            "title": "Adding the files manually"
        }, 
        {
            "location": "/include_in_project/#import-frameworks", 
            "text": "Download the latest version from  Git Hub  Extract the zip archive  Drag   drop the BeaconForStoreSDK.framework onto your project  Check the \"Copy items if needed\" box  Add the Framework to your application target  Click \"Finish\"", 
            "title": "Import frameworks"
        }, 
        {
            "location": "/include_in_project/#add-linker-flags", 
            "text": "Open Project Settings -  Build Settings  Scroll to the \"Linking\" section   In \"Other Linker Flags\" add \"-ObjC\" (this setting is case-sensitive) and \"-lsqlite3\"", 
            "title": "Add linker flags"
        }, 
        {
            "location": "/include_in_project/#import-beaconforstorestoragebundle", 
            "text": "Drag   drop the BeaconForStoreStorage.bundle onto your project  Check the \"Copy items if needed\" box  Add the bundle to your application target  Click \"Finish\"   Check if the bundle appears in the \"Copy File\" step of your application target", 
            "title": "Import BeaconForStoreStorage.bundle"
        }, 
        {
            "location": "/include_in_project/#use-cocoa-pods", 
            "text": "Add   pod 'BeaconForStoreSDK' to the \"target\" section of your podfile   Run the pod install command", 
            "title": "Use Cocoa Pods"
        }, 
        {
            "location": "/include_in_project/#configure-application-modes", 
            "text": "To be able to track the beacons even when in background mode, you must enable background modes in your application.   Select your project in the Project navigator  Select your application target  Select the \"Capabilities\" tab  Turn on \"Background Modes\"   Check the \"Background fetch\" mode     The application will be started by iOS when entering a geofence region or detecting an iBeacon, thus the didFinishLaunchingWithOptions: method from your app delegate will be called.  So if your app calls a tagging / analytics tool (Flurry, Google Analytics...) from this method, your metrics will be eroneous. You should use the  'applicationWillEnterForeground' delegate method to track application launches instead.", 
            "title": "Configure application modes"
        }, 
        {
            "location": "/include_in_project/#add-keys-to-infoplist", 
            "text": "Starting with iOS8, you  must  add a key to your Info.plist to be able to get the user location.   Open your Info.plist file  Add a NSLocationAlwaysUsageDescription key  Set its value to a string describing the reason for accessing the user\u2019s location information   The Backgound Location is needed by the SDK to allow a caching mechanism of the contextual contents associated to the iBeacon around the user. By using this cache, the SDK deals with the scalability of the contextual contents produced in the Neerby plateform (not all the contents available are downloaded into all active user smartphone) , and allow the user to receive the content when he comes in range of the known iBeacon, even if he has no network at this stage (ie. inside a store)  Please see  this document  for more information  Starting with iOS 10 (and app compiled with the Xcode 8 toolchain) you must explain why you app uses Bluetooth otherwise the binary is rejected on iTunes Connect   Open your Info.plist file  Add a NSBluetoothPeripheralUsageDescription key  Set its value to a string describing the reason for accessing Bluetooth", 
            "title": "Add keys to Info.plist"
        }, 
        {
            "location": "/using_the_sdk/", 
            "text": "Depending on how you use the Neerby SDK, some steps are mandatory, some are optional.\n\n\n\n\nBase integration for counting visits\n\n\nRecording user data\n\n\nBeacon-based notifications\n\n\nApplication tagging\n\n\nPush notifications\n\n\n\n\nBase integration\n\n\nThe base integration requires the following steps.\n\n\n\n\nIn your Info.plist file add a \nNeer.By AppID\n key containg the Application ID provied by Ezeeworld\n\n\nImport the Framework In your AppDelegate.m\n\n\n\n\n@import BeaconForStoreSDK;\n\n\n\n\n@import BeaconForStoreSDK\n\n\n\n\n\n\nStart the SDK in the application:didFinishLaunchingWithOptions: method: \n\n\n\n\n[[B4SSingleton sharedInstance] start];\n\n\n\n\nB4SSingleton.sharedInstance().start()\n\n\n\n\nRecording user data\n\n\nNeerby can relate events tot individual customers. Supplying the customer details is typically done on startup and/or after a user signed in to his/her account. In these cases you can update te SDK with this customer data (which is persisted; no need to call this every time). The key should use reverse-dns-like notation to be used as a domain. For instance, the user hometown should use a \"user.hometown\" key.\n\n\n[[B4SSingleton sharedInstance] setUserName:@\nBernard\n firstName:@\nVanCode\n gender:B4SCustomerGender_MALE email:@\nbernard@vancode.com\n customerRef:@\n90210\n];\n[B4SSingleton sharedInstance] setUserProperty:kB4SUserPropertyUserFirstNameKey withString:@\nBernard\n];\n[[B4SSingleton sharedInstance] setUserProperty:kB4SUserPropertyUserLastNameKey withString:@\nVanCode\n];\n[[B4SSingleton sharedInstance] setUserProperty:kB4SUserPropertyUserGenderKey withGender:B4SCustomerGender_MALE];\n[[B4SSingleton sharedInstance] setUserProperty:kB4SUserPropertyUsereMailKey withString:@\nbernard@vancode.com\n];\n[[B4SSingleton sharedInstance] setUserProperty:kB4SUserPropertyUserCustomerRefNameKey withString:@\n90210\n];\n\n\n\n\nB4SSingleton.sharedInstance().setUserProperty(kB4SUserPropertyUserFirstNameKey, withString: \nBernard\n)\nB4SSingleton.sharedInstance().setUserProperty(kB4SUserPropertyUserLastNameKey, withString: \nVanCode\n)\nB4SSingleton.sharedInstance().setUserProperty(kB4SUserPropertyUserGenderKey, withGender: B4SCustomerGender_MALE)\nB4SSingleton.sharedInstance().setUserProperty(kB4SUserPropertyUsereMailKey, withString: \nbernard@vancode.com\n)\nB4SSingleton.sharedInstance().setUserProperty(kB4SUserPropertyUserCustomerRefNameKey, withString: \n90210\n)\n\n\n\n\nBeacon-based notifications\n\n\nThe Neerby SDK uses local notifications to establish communication between beacons and the app.\n\n\nImplement the application:didReceiveLocalNotification: method in your appDelegate. A notification will be sent by the SDK when a notification is fired. You can use the UILocalNotification.userInfo to process the notification yourself. But if you set up some automatic action in the B4S Manager application or using the web app, you must call the [B4SSingleton notificationFeedback:] method. So, the SDK will display a confirmation panel (if any) and process one of the requested predefined actions.\n\n\n    - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification\n    {\n        [[B4SSingleton sharedInstance] notificationFeedback:notification.userInfo];\n    }\n\n\n\n\n    func    application(application: UIApplication, didReceiveLocalNotification notification: UILocalNotification) {\n        B4SSingleton.sharedInstance().notificationFeedback(notification.userInfo)\n    }\n\n\n\n\nAfter processing a notification, a kB4SNotificationProcessedNotification event is fired by the SDK. The notification type is a B4SActionType that you can get using \n[[notificationData.userInfo objectForKey:kB4SNotifActionId] intValue]\n\n\nApplication tagging\n\n\nYou can tag your application with the B4S SDK. You can set two values : The first parameter is the event descriptor and the second the userData asociated to the event. Use the [B4STag event:userData:] and  [B4STag event:userData:]  methods\n\n\n    [B4STag event:@\nmenuClose\n userData:@\nmenu_id_42\n];\n    [B4STag event:@\nmenuOpen\n userDict:@{@\nmenu_id\n: @(42), @\nitem_id\n: @(12)}];\n\n\n\n\n    B4STag.event(\nmenuClose\n, userData: \nmenu_id_42\n)\n    B4STag.event(\nmenuOpen\n, userData: [\nmenu_id\n : 42, \nitem_id\n: 12])\n\n\n\n\nB4S Behaviours\n\n\nThis feature allows you to automatically warn the user if Bluetooth, notifications or geolocation are disabled. This setup \nmust\n be done before initializing the B4S Singleton. See the B4SBehaviours class for more details.\n\n\n    [B4SBehaviours warnForBluetooth:true after:0 count:2 andEvery:2 withTitle:@\nBluetooth\n andText:@\nBluetooth is disabled. Do you want to enable it ?\n];\n    [B4SBehaviours warnForGeolocation:true after:3 count:2 andEvery:2 withTitle:@\nGeoloc\n andText:@\nGeolocation is disabled. Do you want to enable it ?\n];\n    [B4SBehaviours warnForNotifications:true after:1 count:2 andEvery:2 withTitle:@\nNotifications\n andText:@\nNotifications are disabled. You need to activate them in order to use this application.\n];\n\n\n\n\n    B4SBehaviours.warnForBluetooth(true, after: 0, count: 2, andEvery: 2, withTitle: \nBluetooth\n, andText: \nBluetooth is disabled. Do you want to enable it ?\n)\n    B4SBehaviours.warnForGeolocation(true, after: 3, count: 2, andEvery: 2, withTitle: \nGeoloc\n, andText: \nGeolocation is disabled. Do you want to enable it ?\n)\n    B4SBehaviours.warnForNotifications(true, after: 1, count: 2, andEvery: 2, withTitle: \nNotifications\n, andText: \nNotifications are disabled. You need to activate them in order to use this application\n)\n\n\n\n\nCustom notifications\n\n\nYou can customize the notification messages and data sent to your application\n\n\n\n\nImplement B4SDelegate in your app delegate\n\n\n\n\n    @interface AppDelegate : UIResponder \nUIApplicationDelegate,B4SDelegate\n\n\n\n\n\n    class AppDelegate: UIResponder, UIApplicationDelegate, B4SDelegate {\n\n\n\n\n\n\nIn your application:didFinishLaunchingWithOptions: method: set the singleton delegate to your app delegate \nafter\n calling [B4SSingleton setupSharedInstanceWithAppId:]\n\n\n\n\n    [B4SSingleton sharedInstance].delegate = self;      \n\n\n\n\n    B4SSingleton.sharedInstance().delegate = self\n\n\n\n\n\n\nImplement the [B4SDelegate customizeNotificationText:andData:andUserInfo:completion:] in your app delegate\n\n\n\n\n    - (void)customizeNotificationText:(NSString *)aText\n                              andData:(NSString *)aData\n                          andUserInfo:(NSMutableDictionary *)userInfos\n                           completion:(void (^)(NSString *pushText, NSString *pushData, NSMutableDictionary *userInfos))completion {\n        if (completion) {\n            NSLog(@\n[customizeNotificationText] surround notification text with braces\n);\n            completion([NSString stringWithFormat:@\n[%@]\n,aText], aData, userInfos);\n        }\n    }\n\n\n\n\nfunc        customizeNotificationText(aText: String!, andData aData: String!, andUserInfo userInfos: NSMutableDictionary!, completion: ((String!, String!, NSMutableDictionary!) -\n Void)!) {\n    if completion {\n        print(\ncustomizeNotificationText: surround notification text with braces\n)\n        completion(\n[\\(aText)]\n, aData, userInfos)\n        }\n\n\n\n\nCustom alert sound\n\n\n\n\nChange the sound played when you app shows a notification to the user. The sound file must be in .caf (Core Audio File) format and imported into your project\n\n\n\n\n    [[B4SSingleton sharedInstance] setNotificationSoundname:@\nsound.caf\n];\n\n\n\n\n    B4SSingleton.sharedInstance().notificationSoundname = \nsound.caf\n\n\n\n\n\nPush notifications\n\n\nTo use remote push notifications you must first follow the instructions of the \"Base integration\" and \"Beacon-based notifications\" sections\n\n\nCertificates\n\n\n\n\nFollow \n Apple Developer documentation\n on how to get Certificates for push notifications\n\n\n\n\nTarget configuration\n\n\n\n\nSelect your application target\n\n\nSelect the \"Capabilities\" tab\n\n\nSet Push Notifications to \"On\"\n     \n\n\nIn Background Modes enable \"Remotes Notifications\" in addition to \"Background Fetch\"\n    \n\n\n\n\nCode\n\n\n\n\nAfter initializing the SDK with the setupSharedInstanceWithAppId: call enablePushNotifications:\n\n\n\n\n[[B4SSingleton sharedInstance] enablePushNotifications];\n\n\n\n\nB4SSingleton.sharedInstance().enablePushNotifications()\n\n\n\n\n\n\nImplement application:didRegisterForRemoteNotificationsWithDeviceToken: in your app delegate:\n\n\n\n\n- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken\n{\n    [[B4SSingleton sharedInstance] registerPushNotificationDeviceToken:deviceToken];\n}\n\n\n\n\n func application(application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: NSData) \n{\n    B4SSingleton.sharedInstance().registerPushNotificationDeviceToken(deviceToken)\n}\n\n\n\n\n\n\nImplement application:didReceiveRemoteNotification: in your app delegate:\n\n\n\n\n- (void)application:(UIApplication \u200b*)application didReceiveRemoteNotification:(NSDictionary *\u200b)userInfo\n{\n    [B4SSingleton sharedInstance] notificationFeedback:userInfo];\n}\n\n\n\n\n  func application( application: UIApplication, didReceiveRemoteNotification userInfo: [NSObject : AnyObject])\n{\n    B4SSingleton.sharedInstance().notificationFeedback(userInfo)\n    }\n\n\n\n\nUsing a transient device UUID\n\n\nWarning\n: using this feature is \nnot\n recommended\n\n\nUpon the app installation, an anymous device UUID is generated and stored in the Keychain to be read back if the app is un-installed then re-installed. To make this ID transient add a \nNeer.By Use transient DeviceID\n key to your Info.plist, with a \nString\n type and a value of \nYES\n\n\nkey\nNeer.By Use transient DeviceID\n/key\n\n\nstring\nYES\n/string", 
            "title": "Using the SDK"
        }, 
        {
            "location": "/using_the_sdk/#base-integration", 
            "text": "The base integration requires the following steps.   In your Info.plist file add a  Neer.By AppID  key containg the Application ID provied by Ezeeworld  Import the Framework In your AppDelegate.m   @import BeaconForStoreSDK;  @import BeaconForStoreSDK   Start the SDK in the application:didFinishLaunchingWithOptions: method:    [[B4SSingleton sharedInstance] start];  B4SSingleton.sharedInstance().start()", 
            "title": "Base integration"
        }, 
        {
            "location": "/using_the_sdk/#recording-user-data", 
            "text": "Neerby can relate events tot individual customers. Supplying the customer details is typically done on startup and/or after a user signed in to his/her account. In these cases you can update te SDK with this customer data (which is persisted; no need to call this every time). The key should use reverse-dns-like notation to be used as a domain. For instance, the user hometown should use a \"user.hometown\" key.  [[B4SSingleton sharedInstance] setUserName:@ Bernard  firstName:@ VanCode  gender:B4SCustomerGender_MALE email:@ bernard@vancode.com  customerRef:@ 90210 ];\n[B4SSingleton sharedInstance] setUserProperty:kB4SUserPropertyUserFirstNameKey withString:@ Bernard ];\n[[B4SSingleton sharedInstance] setUserProperty:kB4SUserPropertyUserLastNameKey withString:@ VanCode ];\n[[B4SSingleton sharedInstance] setUserProperty:kB4SUserPropertyUserGenderKey withGender:B4SCustomerGender_MALE];\n[[B4SSingleton sharedInstance] setUserProperty:kB4SUserPropertyUsereMailKey withString:@ bernard@vancode.com ];\n[[B4SSingleton sharedInstance] setUserProperty:kB4SUserPropertyUserCustomerRefNameKey withString:@ 90210 ];  B4SSingleton.sharedInstance().setUserProperty(kB4SUserPropertyUserFirstNameKey, withString:  Bernard )\nB4SSingleton.sharedInstance().setUserProperty(kB4SUserPropertyUserLastNameKey, withString:  VanCode )\nB4SSingleton.sharedInstance().setUserProperty(kB4SUserPropertyUserGenderKey, withGender: B4SCustomerGender_MALE)\nB4SSingleton.sharedInstance().setUserProperty(kB4SUserPropertyUsereMailKey, withString:  bernard@vancode.com )\nB4SSingleton.sharedInstance().setUserProperty(kB4SUserPropertyUserCustomerRefNameKey, withString:  90210 )", 
            "title": "Recording user data"
        }, 
        {
            "location": "/using_the_sdk/#beacon-based-notifications", 
            "text": "The Neerby SDK uses local notifications to establish communication between beacons and the app.  Implement the application:didReceiveLocalNotification: method in your appDelegate. A notification will be sent by the SDK when a notification is fired. You can use the UILocalNotification.userInfo to process the notification yourself. But if you set up some automatic action in the B4S Manager application or using the web app, you must call the [B4SSingleton notificationFeedback:] method. So, the SDK will display a confirmation panel (if any) and process one of the requested predefined actions.      - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification\n    {\n        [[B4SSingleton sharedInstance] notificationFeedback:notification.userInfo];\n    }      func    application(application: UIApplication, didReceiveLocalNotification notification: UILocalNotification) {\n        B4SSingleton.sharedInstance().notificationFeedback(notification.userInfo)\n    }  After processing a notification, a kB4SNotificationProcessedNotification event is fired by the SDK. The notification type is a B4SActionType that you can get using  [[notificationData.userInfo objectForKey:kB4SNotifActionId] intValue]", 
            "title": "Beacon-based notifications"
        }, 
        {
            "location": "/using_the_sdk/#application-tagging", 
            "text": "You can tag your application with the B4S SDK. You can set two values : The first parameter is the event descriptor and the second the userData asociated to the event. Use the [B4STag event:userData:] and  [B4STag event:userData:]  methods      [B4STag event:@ menuClose  userData:@ menu_id_42 ];\n    [B4STag event:@ menuOpen  userDict:@{@ menu_id : @(42), @ item_id : @(12)}];      B4STag.event( menuClose , userData:  menu_id_42 )\n    B4STag.event( menuOpen , userData: [ menu_id  : 42,  item_id : 12])", 
            "title": "Application tagging"
        }, 
        {
            "location": "/using_the_sdk/#b4s-behaviours", 
            "text": "This feature allows you to automatically warn the user if Bluetooth, notifications or geolocation are disabled. This setup  must  be done before initializing the B4S Singleton. See the B4SBehaviours class for more details.      [B4SBehaviours warnForBluetooth:true after:0 count:2 andEvery:2 withTitle:@ Bluetooth  andText:@ Bluetooth is disabled. Do you want to enable it ? ];\n    [B4SBehaviours warnForGeolocation:true after:3 count:2 andEvery:2 withTitle:@ Geoloc  andText:@ Geolocation is disabled. Do you want to enable it ? ];\n    [B4SBehaviours warnForNotifications:true after:1 count:2 andEvery:2 withTitle:@ Notifications  andText:@ Notifications are disabled. You need to activate them in order to use this application. ];      B4SBehaviours.warnForBluetooth(true, after: 0, count: 2, andEvery: 2, withTitle:  Bluetooth , andText:  Bluetooth is disabled. Do you want to enable it ? )\n    B4SBehaviours.warnForGeolocation(true, after: 3, count: 2, andEvery: 2, withTitle:  Geoloc , andText:  Geolocation is disabled. Do you want to enable it ? )\n    B4SBehaviours.warnForNotifications(true, after: 1, count: 2, andEvery: 2, withTitle:  Notifications , andText:  Notifications are disabled. You need to activate them in order to use this application )", 
            "title": "B4S Behaviours"
        }, 
        {
            "location": "/using_the_sdk/#custom-notifications", 
            "text": "You can customize the notification messages and data sent to your application   Implement B4SDelegate in your app delegate       @interface AppDelegate : UIResponder  UIApplicationDelegate,B4SDelegate       class AppDelegate: UIResponder, UIApplicationDelegate, B4SDelegate {   In your application:didFinishLaunchingWithOptions: method: set the singleton delegate to your app delegate  after  calling [B4SSingleton setupSharedInstanceWithAppId:]       [B4SSingleton sharedInstance].delegate = self;            B4SSingleton.sharedInstance().delegate = self   Implement the [B4SDelegate customizeNotificationText:andData:andUserInfo:completion:] in your app delegate       - (void)customizeNotificationText:(NSString *)aText\n                              andData:(NSString *)aData\n                          andUserInfo:(NSMutableDictionary *)userInfos\n                           completion:(void (^)(NSString *pushText, NSString *pushData, NSMutableDictionary *userInfos))completion {\n        if (completion) {\n            NSLog(@ [customizeNotificationText] surround notification text with braces );\n            completion([NSString stringWithFormat:@ [%@] ,aText], aData, userInfos);\n        }\n    }  func        customizeNotificationText(aText: String!, andData aData: String!, andUserInfo userInfos: NSMutableDictionary!, completion: ((String!, String!, NSMutableDictionary!) -  Void)!) {\n    if completion {\n        print( customizeNotificationText: surround notification text with braces )\n        completion( [\\(aText)] , aData, userInfos)\n        }", 
            "title": "Custom notifications"
        }, 
        {
            "location": "/using_the_sdk/#custom-alert-sound", 
            "text": "Change the sound played when you app shows a notification to the user. The sound file must be in .caf (Core Audio File) format and imported into your project       [[B4SSingleton sharedInstance] setNotificationSoundname:@ sound.caf ];      B4SSingleton.sharedInstance().notificationSoundname =  sound.caf", 
            "title": "Custom alert sound"
        }, 
        {
            "location": "/using_the_sdk/#push-notifications", 
            "text": "To use remote push notifications you must first follow the instructions of the \"Base integration\" and \"Beacon-based notifications\" sections", 
            "title": "Push notifications"
        }, 
        {
            "location": "/using_the_sdk/#certificates", 
            "text": "Follow   Apple Developer documentation  on how to get Certificates for push notifications", 
            "title": "Certificates"
        }, 
        {
            "location": "/using_the_sdk/#target-configuration", 
            "text": "Select your application target  Select the \"Capabilities\" tab  Set Push Notifications to \"On\"\n       In Background Modes enable \"Remotes Notifications\" in addition to \"Background Fetch\"", 
            "title": "Target configuration"
        }, 
        {
            "location": "/using_the_sdk/#code", 
            "text": "After initializing the SDK with the setupSharedInstanceWithAppId: call enablePushNotifications:   [[B4SSingleton sharedInstance] enablePushNotifications];  B4SSingleton.sharedInstance().enablePushNotifications()   Implement application:didRegisterForRemoteNotificationsWithDeviceToken: in your app delegate:   - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken\n{\n    [[B4SSingleton sharedInstance] registerPushNotificationDeviceToken:deviceToken];\n}   func application(application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: NSData) \n{\n    B4SSingleton.sharedInstance().registerPushNotificationDeviceToken(deviceToken)\n}   Implement application:didReceiveRemoteNotification: in your app delegate:   - (void)application:(UIApplication \u200b*)application didReceiveRemoteNotification:(NSDictionary *\u200b)userInfo\n{\n    [B4SSingleton sharedInstance] notificationFeedback:userInfo];\n}    func application( application: UIApplication, didReceiveRemoteNotification userInfo: [NSObject : AnyObject])\n{\n    B4SSingleton.sharedInstance().notificationFeedback(userInfo)\n    }", 
            "title": "Code"
        }, 
        {
            "location": "/using_the_sdk/#using-a-transient-device-uuid", 
            "text": "Warning : using this feature is  not  recommended  Upon the app installation, an anymous device UUID is generated and stored in the Keychain to be read back if the app is un-installed then re-installed. To make this ID transient add a  Neer.By Use transient DeviceID  key to your Info.plist, with a  String  type and a value of  YES  key Neer.By Use transient DeviceID /key  string YES /string", 
            "title": "Using a transient device UUID"
        }, 
        {
            "location": "/application_size/", 
            "text": "Summary\n\n\nIncluding the Neerby SDK in your application increases it size about 1.7 MB (as of SDK 1.8.3)\n\n\nSDK size\n\n\nThe SDK is distributed as a .framework that contains a static library. This library is pretty heavy as it includes:\n\n\n\n\ncompiled code for 4 CPU architectures  (armv7 \n arm64 for actual devices, i386 \n X86_64 for simulators)\n\n\ndebug symbols\n\n\nBitcode\n\n\n\n\nIncluding all those elements allows:\n\n\n\n\none SDK distribution for all architectures\n\n\ncreation of proper dSym files for use with tools such as Crashlytics\n\n\n\n\nuse of Bitcode features\n\n\nThe SDK with / without those features would be:\n\n\n\n\n\n\n\n\n\n\n\n\nSDK size in MB\n\n\nWith bitcode\n\n\nWithout bitcode\n\n\n\n\n\n\n\n\n\n\nWith debug symbols\n\n\n23\n\n\n8,5\n\n\n\n\n\n\nWithout debug symbol\n\n\n17,4\n\n\n8,3\n\n\n\n\n\n\n\n\nWe can see that most of the bloat is from the inclusion of bitcode, that is an \nintermediate representation\n that enables to generate code for any CPU architecture \n\n\nApplication size\n\n\nWhen compiling an app that includes the Neerby SDK, only the necessary architectures are included in the binary: for instance when generating an app for the App Store the i386 et X86_64 architectures are not included.\n\n\nSince Xcode 7 and iOS 9 the size of the .app generated by Xcode bears little relation with the size of the app that will be downloaded by the user because of the inclusion of bitcode. \nWhen downloading the app:\n\n\n\n\nThe bitcode is never included\n\n\nIf the device is running iOS 8 or below both architecture are downloaded (armv7 \nand\n arm64)\n\n\nIf the device is running iOS 9 only the current device architecture is downloaded (armv7 \nor\n arm64)\n\n\n\n\nSource\n\n\nMeasured application size\n\n\nTo simulate those various sizes we created a minimalistic Xcode project with only the default files\n\n\n\n\nMinimal iOS app, without Neerby SDK: 238 KB\n\n\nThis app + Neerby SDK, with all Xcode settings to default:  6.948 MB\n\n\nThis app + Neerby SDK + \"Enabled bitcode\" set to No: 1.912 MB (this simulate the size of the app download by a iOS 8 user)\n\n\nThis app + Neerby SDK + \"Enabled bitcode\" set to No + \"ARCHS\" set to \"arm64\": 1.176 MB (this simulate the size of the app download by a iOS 9 user running an iPhone 5s or more recent )", 
            "title": "Application size"
        }, 
        {
            "location": "/application_size/#summary", 
            "text": "Including the Neerby SDK in your application increases it size about 1.7 MB (as of SDK 1.8.3)", 
            "title": "Summary"
        }, 
        {
            "location": "/application_size/#sdk-size", 
            "text": "The SDK is distributed as a .framework that contains a static library. This library is pretty heavy as it includes:   compiled code for 4 CPU architectures  (armv7   arm64 for actual devices, i386   X86_64 for simulators)  debug symbols  Bitcode   Including all those elements allows:   one SDK distribution for all architectures  creation of proper dSym files for use with tools such as Crashlytics   use of Bitcode features  The SDK with / without those features would be:       SDK size in MB  With bitcode  Without bitcode      With debug symbols  23  8,5    Without debug symbol  17,4  8,3     We can see that most of the bloat is from the inclusion of bitcode, that is an  intermediate representation  that enables to generate code for any CPU architecture", 
            "title": "SDK size"
        }, 
        {
            "location": "/application_size/#application-size", 
            "text": "When compiling an app that includes the Neerby SDK, only the necessary architectures are included in the binary: for instance when generating an app for the App Store the i386 et X86_64 architectures are not included.  Since Xcode 7 and iOS 9 the size of the .app generated by Xcode bears little relation with the size of the app that will be downloaded by the user because of the inclusion of bitcode. \nWhen downloading the app:   The bitcode is never included  If the device is running iOS 8 or below both architecture are downloaded (armv7  and  arm64)  If the device is running iOS 9 only the current device architecture is downloaded (armv7  or  arm64)   Source", 
            "title": "Application size"
        }, 
        {
            "location": "/application_size/#measured-application-size", 
            "text": "To simulate those various sizes we created a minimalistic Xcode project with only the default files   Minimal iOS app, without Neerby SDK: 238 KB  This app + Neerby SDK, with all Xcode settings to default:  6.948 MB  This app + Neerby SDK + \"Enabled bitcode\" set to No: 1.912 MB (this simulate the size of the app download by a iOS 8 user)  This app + Neerby SDK + \"Enabled bitcode\" set to No + \"ARCHS\" set to \"arm64\": 1.176 MB (this simulate the size of the app download by a iOS 9 user running an iPhone 5s or more recent )", 
            "title": "Measured application size"
        }
    ]
}